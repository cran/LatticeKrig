\name{LKrig.basis}
\alias{LKrig.basis}
\alias{LKrig.setup}
\alias{LKrig.precision}
\alias{LKrig.MRF.precision}
\alias{LKrig.cov}
\alias{LKrig.sim}
\title{
Functions for generating a multiresolution, compactly supported basis,  
multiresolution covariance functions and simulating from these processes.
}
\description{
These functions support the \code{LKrig} function.  Creates radial
 basis functions of varying support on a nested set of regular grids.
 These series of grids form a multiresolution basis.  The Gaussian
 process model is an expansion in these basis functions where the
 basis coefficients follow a Markov random field model for each
 resolution level.  This family of functions generate the basis using
 sparse matrices, evaluate the covariance function of the process and
 also simulate realizations of the process.  }

\usage{
LKrig.setup(x = NULL, NC, grid.info = NULL, nlevel = 1, alpha = 1, 
              a.wght = NULL, beta = NULL, overlap = 2.5, normalize = TRUE, edge=FALSE) 
LKrig.cov(x1, x2 = NULL, LKinfo, C = NA, marginal = FALSE) 
LKrig.sim(x1, LKinfo, M=1)
LKrig.basis(x1, LKinfo, verbose = FALSE, spam.format = TRUE)
LKrig.precision(LKinfo, return.B = FALSE)  
LKrig.MRF.precision(mx,my, a.wght, edge=FALSE) 
}
\arguments{
 \item{alpha}{A scalar or vector with the relative weights to give the
different precision matrices for each level of coefficients.}

\item{a.wght}{A scalar or vector that are the weights of the center
points in the Markov random fields at each level with the 4 nearest
neighbors given weight -1. The weights should be greater than 4 for
the fields to be stationary.}

\item{beta}{A scalar or vector giving the lattice connection strengths
used to construct the precision matrix for each resolution level. (The
"a" parameterization with \code{a.wght} is recommended instead of this
form.)}

\item{C}{If passed the covariance matrix will be multiplied by this
vector or matrix.}

\item{edge}{If FALSE no adjustments are made to edges.}

\item{grid.info}{A list with components \code{xmin, xmax, ymin, ymax,
 delta} that specifies the range and spacing for the coarsest level
 grid.}

 \item{LKinfo}{A list with components that give the information
  describing a multiresolution basis with a Markov random field used
  for the covariance of the basis coefficients. This list is created
  in \code{LKrig} or by \code{LKrig.setup} and returned in the output
  object.  (See s.b ection on returned Value below for this list's
  description.)}

\item{marginal}{If TRUE returns the marginal variance. Currently not
implemented!}

\item{M}{Number of simulated fields.}
 
\item{NC}{Maximum number of grid points in either the x or y
 directions to determine the basis function centers. If the region is
 square then this will be \code{NC} grid points in each dimension
 giving a total \code{NC^2} grid points/basis functions. }

\item{nlevel}{Number of levels in multiresolution. Note that each
subsequent level increases in size by a factor of 4= 2x2. }

\item{mx}{Number of grid points in x dimension.}

\item{my}{Number of grid points in the y dimension.}

\item{overlap}{The amount of overlap between basis functions. If the
grid spaciing in x and y is \code{delta} then the support of the basis
functions will be \code{overlap*delta}.  This value is hardwired to
2.5 in \code{LKrig} and also the default in \code{LKrig.setup}}
 
\item{normalize}{If TRUE this output list argument will indicate the
basis functions will be normalized to give a marginal variance of
one.}

\item{return.B}{ If TRUE B is returned instead of the precision matrix
t(B)\%*\%B }

\item{spam.format}{ If TRUE matrix is returned in sparse matrix
format.}

\item{x}{Spatial locations for fitting surface. This is used to
determine ranges of the grid for basis functions.}

  \item{x1}{ A two column matrix of 2-dimension locations to evaluate
basis functions or the first set of locations to evaluate the
covariance function or the locations for the simulated process.  Rows
index the different locations: to be precise \code{x1[i,1:2]} are the
"x" and "y" coordinates for the \code{i} th location. }

\item{x2}{Second set of locations to evaluate covariance function.}

\item{verbose}{If TRUE intermediate steps and information is printed.}

} \details{ The basis functions are two-dimensional radial basis
functions based on the Wendland covariance function, centered on
regular grid points and with the scaling tied to the spacing of the
grid points.

For a basis at the coarest level, the grid centers are generated by
expanding the sequences \code{seq(grid.info$xmin,
grid.info$xmax,grid.info$delta)} \code{seq(grid.info$ymin,
grid.info$ymax,grid.info$delta)} into a regular grid of center
points. The same spacing \code{delta} is used in both directions.  The
unnormalized basis functions are evaluated at locations \code{x1} by
finding the pairwise, radial distances among \code{centers} and
\code{x1}, scaling by \code{grid.info$delta * overlap} and then
evaluating the 2-d Wendland covariance with order 2.  Perhaps the most
important point about this R-function is that it is designed to return
a matrix of all basis functions as a sequence of points. There is no
need to have a function that evaluates basis functions individually.
In R code for a set of locations \code{x1} and a rectangular spatial
domain with ranges \code{xmin, xmax, ymin ,ymax}:

\preformatted{
 centers<- expand.grid(seq(xmin,xmax,delta),
                       seq(ymin,ymax,delta) )
 bigD<- rdist( x1, centers)/(delta*2.5)
 PHI<- Wendland.function( bigD)
} 
Note that there will be \code{nrow(centers)} basis functions generated
where the precise number depends on the range of the domain and the
choice of delta. The basis functions are indexed by the columns in
\code{PHI} and this is a convention throughout this package.  There
will \code{nrow(x1)} rows in \code{PHI} as each basis function will be
evaluted at each 2-d location.

The basis functions are then normalized by scaling the basis functions
at each location so that resulting marginal variance of the process is
1. This is done to coax the covariance model closer to a stationary
representation. It is easiest to express this normalization as pseudo
R code:

If Sigma is the covariance matrix of the basis coefficients  
\preformatted{
process.variance <- diag(PHI\%*\% Sigma \%*\%t(PHI) )
PHI.normalized <-  diag( 1/sqrt(process.variance)) \%*\% PHI
}

The actual code uses the function \code{Wendland.basis} to take
advantage of some FORTRAN routines and spam functions for creating
sparse formats. The normalization also uses sparse matrix methods and
works with the precision matrix of the coefficients instead of the
covariance. Moreover, the quadratic form comprising the process
variance is more efficiently computed using a Cholesky factorization
of \code{Q}.

The precision matrix for the basis coefficients at each resolution has
 the form \code{t(B)\%*\% B}. These matrices for the individual levels
 are assembled by \code{LKrig.precision} as the block diagonals of a
 larger precision matrix for the entire vector of coefficients. Note
 these matrices are also created in a sparse format.  The specific
 entries in B, the object created by \code{LKrig.MRF.precision}, are a
 first order Markov random field: without edge adjustments the
 diagonal elements have the value \code{a.wght} and the first order
 neighbors have the value -1.

Below we give more details on how elements are modified for edge
effects.  Following the notation in Lindgren and Rue a= 4 + k2 with k2
greater than or equal to 0.  and some schematics for filling in the B
matrix are
\preformatted{

       -1                -1                    4+k2  -1
                   
  -1  4+k2  -1           4+k2  -1               -1

       -1                -1

Interior point        Left edge when           Upper left corner when 
                      edge is FALSE            edge is FALSE
}
 

If \code{edge} is TRUE the edges are weighted to reflect other boundary conditions. 
\preformatted{

       -1                -.5                    1+k2/4  -.5
                   
  -1  4+k2  -1           2+k2/2  -1               -.5

       -1                -.5

Interior point        Left edge when           Upper left corner when 
                      edge is TRUE            edge is TRUE
}



}
\value{

\code{LKrig.basis}
A matrix with number of rows equal to the rows of \code{x1} and columns equal to the number of 
basis functions ( LKinfo$m). Attached to the matrix is an  \code{info} attribute that contains the 
list passed as \code{LKinfo}. 

\code{LKrig.setup}
A list with components giving the numbers of basis functions at each level and the information to 
reconstruct the grid for the basis centers. Also contains the parameters of the Markov random fields and 
a logical to indicate whether to normalize the basis functions to a constant marginal variance. 

\code{LKrig.precision} A sparse, square matrix with dimensions of the number of basis functions.
If \code{return.B} is FALSE then this is the  precision matrix for the basis coefficients. 

\code{LKrig.MRF.precision} A sparse square matrix with dimension (mx*my by mx*my)  with a.wght on the diagonal 
and -1 in the positions for the 4 nearest neighboring points. Note that this matrix has dimensions of the number of grid points/ basis functions  (mx*my by mx*my) -- not  mx x my.  So the indexing of nearest neighbors is a little more complicated that in 1-dimensional grids. 

\code{LKrig.cov} If \code{C=NA} a cross covariance matrix with dimensions \code{nrow(x1)} and 
\code{nrow(x2)}. 
If \code{C} is passed the result of multiplying the cross covariance matrix times \code{C}.

\code{LKrig.sim} A  matrix with dimensions of \code{nrow(x1)} by \code{M} of simulated values at the locations \code{x1}. 

}
\author{
Doug Nychka
}

\seealso{
LKrig, mKrig, Krig, fastTps, Wendland
}
\examples{
# generating a basis on the domain [-1,1] by [-1,1] with 1 level
  ginfo<- list( xmin=-1, xmax=1, ymin=-1, ymax=1, delta= 2/(6-1))
# this is the same as setting NC=6
  LKinfo<- LKrig.setup(grid.info=ginfo, nlevel=1, a.wght=4.5,alpha=1 )
# evaluate the basis functions on a grid to look at them
  xg<- make.surface.grid( list(x=seq(-1,1,,50), y= seq(-1,1,,50)))
  PHI<- LKrig.basis( xg,LKinfo)
  dim(PHI) # should be  2500=50^2  by  36=6^2
# plot the 9th basis function  as.surface is a handy function to reformat the vector as an image object
# using the grid information in an attribute of the grid points ( xg in this case)
  image.plot(as.surface(xg, PHI[,9]))
#
# See a more elaborate example at the end that illustrates indexing and 
#  the basis shapes
#
# create four resolution levels of basis functions 
# take a look at the covariance function 
  NL<-4
  a.wght<-  c(rep(4.5,3),10) # cranking up the range!
  alpha<- c(rep(1,3),.2)
#  lazy way to add the the grid info just give two points that are the domain corners 
#  and also NC to define the spacing of basis functions for first level. 
  xg<- make.surface.grid( list(x=seq(-1,1,,50), y= seq(-1,1,,50)))
  LKinfo<- LKrig.setup(x=cbind(c(-1,1), c(-1,1)) , NC=8, alpha=alpha, a.wght=a.wght, nlevel=NL)
  x0<-  cbind( 0,0)
  hold<-  LKrig.cov(xg,x0,LKinfo )
  image.plot( as.surface(xg, hold))
  xline(0, col="magenta") # line for next example
  title("correlation function with (0,0)")
#
# evaluate the covariance along x-axis to reduce number of points.
  xslice<- cbind( seq(-1,1,,400),0)
  hold<- LKrig.cov(xslice,x0,LKinfo )
  plot( xslice[,1], hold, type="l", xlab="X slice through (0,0)", ylab="correlation")
 
# What does the precision matrix look like at a single level?
# first make up the B matrix
# without edge corrections
  B<- LKrig.MRF.precision( 6,7, a.wght=5, edge=FALSE)
  Bfull<- spind2full(B)
# with edge correction
  Be<- LKrig.MRF.precision( 6,7, a.wght=5, edge=TRUE)
  Befull<- spind2full(Be)
set.panel(2,1)
  image.plot( 1:42, 1:42, Bfull)
  image.plot( 1:42, 1:42, Befull)
# element at row 15,  position (3,3) reshaped to 6X6 image
  image.plot(1:6, 1:7, matrix(Bfull[15,], 6,7))
  image.plot(1:6, 1:7, matrix(Befull[15,], 6,7))
# element at row 13 reshaped to 6X6 image Note edge adjustment
  image.plot(1:6, 1:7, matrix(Bfull[13,], 6,7))
  image.plot(1:6, 1:7, matrix(Befull[13,], 6,7))

# check corners:
  for (  k in c(1,6, 6*(7-1) + 1, 6*7)){
          print(  matrix(Befull[k,], 6,7))}
# check edges:
   for ( k in 2:5){
         print(  matrix(Befull[k,], 6,7))}
   for ( k in (2:5)+ 6*6 ){
          print(  matrix(Befull[k,], 6,7))}
   for(  k in (1:5)*6 +1){
          print(  matrix(Befull[k,], 6,7))}
   for(  k in (1:5)*6 +6){
          print(  matrix(Befull[k,], 6,7))}

   
set.panel()
# 15 th row of precision matrix also reshaped. 
  Q<- t(Befull)\%*\%Befull  
  image.plot( 1:6, 1:7, matrix( Q[15,], 6,7))

#
# simulate 6 realizations of process. 
  out<- LKrig.sim(xg, LKinfo,M=6)
  set.panel(2,3)
  for( k in 1:6){
    image.plot( as.surface( xg, out[,k]), axes=FALSE) }
#
# example of basis function indexing
#
# generating a basis on the domain [-1,1]X[-1,1] with 3 levels
  ginfo<- list( xmin=-1, xmax=1, ymin=-1, ymax=1, delta= 2/3)
  LKinfo<-LKrig.setup( grid.info=ginfo, a.wght=rep(5,3), alpha=rep(1,3), nlevel=3)
# evaluate the basis functions on a grid to look at them
  xtemp<- seq(-1,1,,40)
  xg<- make.surface.grid( list(x=xtemp, y= xtemp) )
  PHI<- LKrig.basis( xg,LKinfo)
# coerce to dense matrix format to make plotting easier.
  PHI<- spam2full(PHI)
# first tenth, and last basis function in each resolution level
# basis functions centers are added
  set.panel(3,3)
  grid.info<- LKinfo$grid.info
  for(  j in 1:3){
    id1<- LKinfo$offset[j]+ 1
    id2<-  LKinfo$offset[j]+ 10
    idlast<- LKinfo$offset[j]+ LKinfo$mx[j]*LKinfo$my[j]

    centers<-  make.surface.grid( list( 
                                 x= seq(grid.info$xmin, grid.info$xmax, LKinfo$delta[j]),
                                 y= seq(grid.info$xmin, grid.info$xmax, LKinfo$delta[j]) ) )
    image.plot(as.surface(xg, PHI[,id1]))
    points( centers, cex=.2, col="grey")
    image.plot(as.surface(xg, PHI[,id2]))
    points( centers, cex=.2, col="grey")
    image.plot(as.surface(xg, PHI[,idlast]))
    points( centers, cex=.2, col="grey")}

}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{spatial}

