# LatticeKrig  is a package for analysis of spatial data written for
# the R software environment .
# Copyright (C) 2012
# University Corporation for Atmospheric Research (UCAR)
# Contact: Douglas Nychka, nychka@ucar.edu, 
# National Center for Atmospheric Research, PO Box 3000, Boulder, CO 80307-3000
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with the R software environment if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# or see http://www.r-project.org/Licenses/GPL-2

which.max.matrix<- function(z){
  if( !is.matrix(z)){
    stop( "Not a matrix")} 
  m<- nrow(z)
  n<- ncol(z)  
  # take care of NAs  
  ind<- which.max(z)
  iy<- trunc( (ind-1) /m) + 1
  ix<- ind - (iy-1)*m 
  return( cbind( ix,iy))
}


which.max.image<- function(obj){
  ind.z<- which.max.matrix( obj$z)
  return( list( x= obj$x[ind.z[,1]], y= obj$y[ind.z[,2]], z=obj$z[ ind.z], ind=ind.z) )  }


MLE.search.LKrig<- function( x,y,par.grid,
                            NC=NULL,nlevel=NULL,
                            LKinfo=NULL,
                            verbose=TRUE, ...){
# fill out covarinance parameters using the base model in LKinfo if they are not specificed
# a.wght is either changed in call or values from par.gird will be used. 
  if(is.null(LKinfo)){ 
    LKinfo<- LKrig.setup( x,NC=NC, nlevel=nlevel)}
 
 
# at this point LKinfo has the correct value for the number of multiresolution levels  
  nlevel<- LKinfo$nlevel
  par.grid.temp<- LKrig.make.par.grid( par.grid=par.grid,  LKinfo=LKinfo)
  if( verbose){
    cat("par.grid", fill=TRUE)
    print( par.grid.temp)}
# output matrix
  NG<- nrow( par.grid.temp$llambda)
  out<- matrix( NA, nrow=NG,ncol=5)
  dimnames( out)<- list( NULL,
                        c("EffDf", "lnProfLike", "GCV", "sigma.MLE", "rho.MLE"))
  LKinfo.temp<- LKinfo
  for ( k in 1:NG){
    lambda.temp<- exp(par.grid.temp$llambda[k])
    LKinfo.temp$a.wght<- c(par.grid.temp$a.wght[k,])
    LKinfo.temp$alpha<- c(par.grid.temp$alpha[k,])
    if( k ==1){
    # fit first model  and also to create/save
    #  parts of cholesky decoposition that can be reused (MC component).
      obj <- LKrig( x,y, LKinfo = LKinfo.temp, lambda=lambda.temp, ... )
      LKrig.call<- obj$call
      MC.save<- obj$MC}
    else{
      obj <- LKrig( x,y, LKinfo = LKinfo.temp, lambda= lambda.temp,...,
                             use.cholesky= MC.save)}
    out[k,1] <- obj$trA.est
    out[k,2] <- obj$lnProfileLike
    out[k,3] <- obj$GCV
    out[k,4] <- obj$sigma.MLE
    out[k,5] <- obj$rho.MLE
    if( verbose){
      cat("  ", k, out[k,1:5],  fill=TRUE)}
  } 
  index.MLE<- which.max(out[,2])
  index.GCV<- which.max(out[,3])
# LKinfo list at the MLE values
  LKinfo.temp<- LKinfo
  lam.temp<- exp(par.grid.temp$llambda[index.MLE])
  LKinfo.temp$alpha<- c(par.grid.temp$alpha[index.MLE,])
  LKinfo.temp$a.wght<- c(par.grid.temp$a.wght[index.MLE,])
  if( !is.null(par.grid.temp$gamma)){
     par.matrix<- cbind( par.grid.temp$gamma, par.grid.temp$lkappa, par.grid.temp$llambda)
     col.labels<-  c(paste( "gamma", 1:ncol(par.grid.temp$gamma), sep=""),
                     paste( "lkappa", 1:ncol(par.grid.temp$lkappa), sep=""),
                            "llambda")
     dimnames( par.matrix)<- list( NULL, col.labels)}
  else{
      par.matrix<- cbind( par.grid.temp$lkappa, par.grid.temp$llambda)
      col.labels<-  c(paste( "lkappa", 1:ncol(par.grid.temp$lkappa), sep=""),
                            "llambda")
      dimnames( par.matrix)<- list( NULL, col.labels)}  
  return( list(out=out,par.grid=par.grid.temp, par.matrix= par.matrix, LKinfo=LKinfo,
               index.MLE= index.MLE, index.GCV=index.GCV,
               par.MLE= par.matrix[index.MLE,],
               LKinfo.MLE= LKinfo.temp,
               lambda.MLE=lam.temp,
               call=match.call(), LKrig.call= LKrig.call, X.temp= par.matrix, Y.temp=out[,2])
         )
}
